
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>RoiFactory</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-08-14"><meta name="DC.source" content="RoiFactory.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">ROIFACTORY creates ROIs, reads from and writes to a filesystem.</a></li><li><a href="#4">THRESHOLDROIBYSTD determines a statistical threshold for a floating-point mask</a></li><li><a href="#7">Static  THRESHOLDROI_COVERAGE determines a statistical threshold for</a></li><li><a href="#10">MAKEARTERIESROI constructs a probability map of arteries from DSC data</a></li><li><a href="#13">REGISTERTOMODALITIES</a></li><li><a href="#16">TABULATEMODALROIS displays a table of cell-array metrics</a></li><li><a href="#17">prepare all inputs as RoiFactories</a></li><li><a href="#18">prepare rescaled metrics</a></li><li><a href="#19">initialize modelOks, mcas, fg</a></li><li><a href="#20">ipsi(modelOks), contra(modelOks)</a></li><li><a href="#21">ipsi(mcas), contra(mcas); reset ipsi/contra-factories</a></li><li><a href="#22">ipsi(fg), contra(fg); reset ipsi/contra-factories</a></li><li><a href="#23">gray(fg), deep(fg), white(fg), bellum(fg); reset factories</a></li><li><a href="#24">gray(ipsi), deep(ipsi), white(ipsi), bellum(ipsi); reset factories</a></li><li><a href="#25">gray(contra), deep(contra), white(contra), bellum(contra); reset factories</a></li><li><a href="#28">TOFILEPREFIX converts fileprefixes or NIfTIs to well-formed fileprefixes</a></li><li><a href="#31">TONIFTI converts fileprefixes or NIfTIs to well-formed NIfTIs</a></li><li><a href="#34">SAMPLEVOXELS samples metric-voxels with some or all internal ROIs</a></li><li><a href="#37">CTOR</a></li><li><a href="#40">LOAD appends object, converted to NIfTI, to this.theRois</a></li><li><a href="#43">INTERSECTNBYM intersects all this.theRois with the intersection of all miis,</a></li><li><a href="#46">RESCALEBYREFERENCE</a></li></ul></div><pre class="codeinput"><span class="keyword">classdef</span> RoiFactory
</pre><h2>ROIFACTORY creates ROIs, reads from and writes to a filesystem.<a name="2"></a></h2><pre>Created by John Lee on 2009-01-27.
Copyright (c) 2009 Washington University School of Medicine.  All rights reserved.
Report bugs to &lt;email = "bugs.perfusion.neuroimage.wustl.edu@gmail.com"/&gt;.</pre><pre class="codeinput">    properties (Constant)
        MODES   = { <span class="string">'ho15'</span>    <span class="string">'asl1'</span>       <span class="string">'ssvd'</span>}; <span class="comment">% 'bip' };</span>
        ROIS    = { <span class="string">'modelok'</span> <span class="string">'parenchyma'</span> <span class="string">'mca'</span>  <span class="string">'pca'</span> <span class="string">'gray'</span> <span class="string">'deepgray'</span> <span class="string">'white'</span> <span class="string">'left'</span> <span class="string">'right'</span> <span class="string">'Cerebellum'</span> };
        ATLASES = { <span class="string">''</span> <span class="keyword">...</span>
                    <span class="string">'parenchyma-sub-maxprob-thr25-2mm'</span> <span class="keyword">...</span>
                    <span class="string">'MNI152_T1_2mm_JoshsMCA_bilat'</span> <span class="keyword">...</span>
                    <span class="string">'MNI152_T1_2mm_PCA_bilat'</span> <span class="keyword">...</span>
                          <span class="string">'gray-sub-maxprob-thr25-2mm'</span> <span class="keyword">...</span>
                      <span class="string">'deepgray-sub-maxprob-thr25-2mm'</span> <span class="keyword">...</span>
                         <span class="string">'white-sub-maxprob-thr25-2mm'</span> <span class="keyword">...</span>
                         <span class="string">'left-MNI152-2mm'</span> <span class="keyword">...</span>
                        <span class="string">'right-MNI152-2mm'</span> <span class="keyword">...</span>
               <span class="string">'Cerebellum-MNIfnirt-maxprob-thr25-2mm'</span> };
        EP2D    = <span class="string">'ep2d'</span>; <span class="comment">% 'ep2d2'</span>
        TOKEN   = mlfsl.FslFacade.TOKEN;
    <span class="keyword">end</span>

    properties (SetAccess = <span class="string">'protected'</span>)
        theMetric
        theRois <span class="comment">% cell-array of NIfTIs</span>
    <span class="keyword">end</span>

    properties (Dependent)
        metricLabel
        roiLabels
    <span class="keyword">end</span>



    methods (Static)

        <span class="keyword">function</span>   binnii = threshRoiByStd(fpmsk, numstd)
</pre><h2>THRESHOLDROIBYSTD determines a statistical threshold for a floating-point mask<a name="4"></a></h2><pre>                  and uses that threshold to generate a binary mask;
                  uses a multiplier for std
Usage:  binnii = mlfourd.RoiFactory.threshRoiByStd(fpmsk, numstd)
        numstd:  set threshold to be max intensity - numstd*std (optional)
                 otherwise mask coverage will be set to 1 percent of voxels
OBSOLETE, DEPRECATED</pre><pre class="codeinput">            mlfourd.NIfTI.isNIfTI
            maxfp  = dipmax(fpmsk.img);
            stdfp  = dipstd(fpmsk.img);
            <span class="keyword">switch</span> (nargin)
                <span class="keyword">case</span> 1
                    thresh = maxfp;
                    <span class="keyword">for</span> n = 1:floor(maxfp/stdfp)
                        thresh   = thresh - stdfp;
                        coverage = dipsum(double(fpmsk.img &gt; thresh))/ <span class="keyword">...</span>
                                   dipprod(fpmsk.hdr.dime.dim(2:4));
                        <span class="keyword">if</span> (coverage &gt; 0.01)
                            <span class="keyword">break</span>;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">case</span> 2
                    thresh = maxfp - numstd*stdfp;
                <span class="keyword">otherwise</span>
                    error(<span class="string">'mlfourd:InputParamsErr'</span>, <span class="keyword">...</span>
                         [<span class="string">'RoiFactory.threshRoiByStd does not support '</span> num2str(nargin) <span class="string">' input params'</span>]);
            <span class="keyword">end</span>
            bin    = double(fpmsk.img &gt; thresh);
            binnii = fpmsk.makeSimilar(bin, <span class="string">'RoiFactory.threshRoiByStd'</span>);
            disp([<span class="string">'RoiFactory.threshRoiByStd.maxfp -&gt; '</span> num2str(maxfp)]);
            disp([<span class="string">'                        stdfp -&gt; '</span> num2str(stdfp)]);
            disp([<span class="string">'                       thresh -&gt; '</span> num2str(thresh)]);
</pre><pre class="codeinput">        <span class="keyword">end</span> <span class="comment">% static threshRoiByStd</span>
        <span class="keyword">function</span>   binnii = threshRoiByCoverage(fpmsk, cover)
</pre><h2>Static  THRESHOLDROI_COVERAGE determines a statistical threshold for<a name="7"></a></h2><pre>        a floating-point mask and uses that threshold to generate a binary mask;
        uses a fractional coverage parameter
Usage:  binnii = mlfourd.RoiFactory.threshRoiByCoverage(fpmsk, cover)
        numstd:  set threshold to be max intensity - numstd*std (optional)
                 otherwise mask coverage will be set to 1 percent of voxels
OBSOLETE, DEPRECATED</pre><pre class="codeinput">            mlfourd.NIfTI.isNIfTI
            maxfp  = dipmax(fpmsk.img);
            stdfp  = dipstd(fpmsk.img);
            <span class="keyword">if</span> (1 == nargin); cover = 0.00667; <span class="keyword">end</span>
            <span class="keyword">if</span> (nargin &lt; 1 || nargin &gt; 2)
                error(<span class="string">'mlfourd:InputParamsErr'</span>, <span class="keyword">...</span>
                     [<span class="string">'RoiFactory.threshRoiByStd does not support '</span> <span class="keyword">...</span>
                       num2str(nargin) <span class="string">' input params'</span>]);
            <span class="keyword">end</span>
            thresh = maxfp;
            <span class="keyword">for</span> n = 1:floor(maxfp/stdfp)
                thresh   = thresh - stdfp;
                coverage = dipsum(double(fpmsk.img &gt; thresh))/ <span class="keyword">...</span>
                           dipprod(fpmsk.hdr.dime.dim(2:4));
                <span class="keyword">if</span> (coverage &gt; cover)
                    <span class="keyword">break</span>;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            bin    = double(fpmsk.img &gt; thresh);
            binnii = fpmsk.makeSimilar(bin, <span class="string">'RoiFactory.threshRoiByStd'</span>);
            disp([<span class="string">'RoiFactory.threshRoiByStd.maxfp -&gt; '</span> num2str(maxfp)]);
            disp([<span class="string">'                          stdfp -&gt; '</span> num2str(stdfp)]);
            disp([<span class="string">'                         thresh -&gt; '</span> num2str(thresh)]);
</pre><pre class="codeinput">        <span class="keyword">end</span> <span class="comment">% static threshRoiByCoverage</span>
        <span class="keyword">function</span>   nii    = makeArteryRoi(epinii, fgnii)
</pre><h2>MAKEARTERIESROI constructs a probability map of arteries from DSC data<a name="10"></a></h2><pre>Usage:  nii = mlfourd.RoiFactory.makeArteryRoi(epinii, fgnii)
Requires:  diplib</pre><pre class="codeinput">            assert(mlfourd.NIfTI.isNIfTI(epinii));
            assert(mlfourd.NIfTI.isNIfTI(fgnii));
            assert(4 == size(size(epinii.img), 2));                 <span class="comment">% assert 4D time-series</span>
            assert(numel(squeeze(epinii.img(:,:,:,1))) == numel(fgnii.img));
            fg = double(squeeze(fgnii.img) &gt; 0);         <span class="comment">% binary mask</span>

            T_SSTATE       = 4; <span class="comment">% frame at which M is in steady-state</span>
            T_BEFORE_BOLUS = 1; <span class="comment">% look slightly before the bolus peak</span>
                                <span class="comment">% to avoid saturation effects, adjustable</span>
            T_LAST         = size(epinii.img, 4);

            <span class="comment">% determine time of bolus-passage, tBolus</span>
            epiImg = double(epinii.img(:,:,:,T_SSTATE:T_LAST-T_SSTATE));
            epimip = zeros(size(epiImg, 4), 1);
            <span class="keyword">for</span> t = 1:size(epiImg, 4)
                epimip(t) = dipsum(squeeze(epiImg(:,:,:,t)) .* fg);
            <span class="keyword">end</span>
            tBolus = indexOfMin(epimip);

            <span class="comment">% estimate the bolus width from &lt;t - &lt;t&gt;&gt;</span>
            distr      = epimip - epimip(tBolus);
            distr      = max(epimip) - distr;
            times      = (0:length(epimip) - 1)';
            sumdistr   = sum(distr);
            <span class="keyword">if</span> (sumdistr &lt; eps); sumdistr = 1; <span class="keyword">end</span>
            bolusWidth = sum(distr .* times)/sumdistr;


            <span class="comment">% estimate the baseline EPI image</span>
            <span class="keyword">if</span> (bolusWidth/2 &lt; T_BEFORE_BOLUS)
                T_BEFORE_BOLUS = floor(bolusWidth/2); <span class="keyword">end</span>
            tfBaseline = floor(tBolus - T_BEFORE_BOLUS - bolusWidth/2);
            <span class="keyword">if</span> (tfBaseline &lt; T_SSTATE)
                tfBaseline = T_SSTATE; <span class="keyword">end</span>
            epiBaseline = zeros(size(fg));
            <span class="keyword">for</span> t = T_SSTATE:tfBaseline
                epiBaseline = epiBaseline + <span class="keyword">...</span>
                    squeeze(epiImg(:,:,:,t))/(tfBaseline - T_SSTATE + 1);
            <span class="keyword">end</span>

            <span class="comment">% assemble arteries ROI as NIfTI</span>
            arteries = epiBaseline/refValue(epiBaseline) - <span class="keyword">...</span>
                       squeeze( epiImg(:,:,:,tBolus-T_BEFORE_BOLUS)/ <span class="keyword">...</span>
                       refValue(epiImg(:,:,:,tBolus-T_BEFORE_BOLUS)));
            msk      = (arteries &gt; eps) .* fg;
            arteries = msk.*arteries/dipsum(msk.*arteries);
                       <span class="comment">% normalize image values to be probabilities</span>
            nii      = fgnii.makeSimilar( <span class="keyword">...</span>
                       arteries, <span class="string">'from RoiFactory.make_arteriesRois'</span>);

            <span class="keyword">function</span> val = refValue(img)
                val = mode( <span class="keyword">...</span>
                                mlfourd.NiiBrowser.makeSampleVoxels( <span class="keyword">...</span>
                                img, double(img &gt; eps)));
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span> <span class="comment">% static makeArteryRoi</span>

        <span class="keyword">function</span>            prepareMatrices(bldr)
            import <span class="string">mlfsl.*</span> <span class="string">mlfourd.*</span>;
            tpth   = bldr.transformationsPath;
            flirtf = FlirtFacade(bldr);

            iopts.inverse = matFqfn(tpth, <span class="string">'bt1_rot'</span>, <span class="string">'MNI_brain.mat'</span>);
            flirtf.invertxfm(iopts);
            copyfile(              matFqfn(tpth,  <span class="string">'t1_rot'</span>, <span class="string">'hosum_rot_susan5p52mm.mat'</span>),  matFqfn(tpth, <span class="string">'t1'</span>, <span class="string">'ho15.mat'</span>));
            copyfile(matFqfn(tpth, <span class="string">'bpasl_rot_mcf_meanvol'</span>, <span class="string">'bt1_rot.mat'</span>),                matFqfn(tpth, <span class="string">'asl1'</span>, <span class="string">'t1.mat'</span>));

            iopts.inverse = matFqfn(tpth, <span class="string">'asl1'</span>, <span class="string">'t1.mat'</span>);
            flirtf.invertxfm(iopts);
            copyfile(              matFqfn(tpth, <span class="string">'bt1_rot'</span>, [<span class="string">'b'</span> RoiFactory.EP2D <span class="string">'_rot_mcf_meanvol.mat'</span>]),  <span class="keyword">...</span>
                                                                                           matFqfn(tpth, <span class="string">'t1'</span>, <span class="string">'ssvd.mat'</span>));
        <span class="keyword">end</span> <span class="comment">% static prepareMatrices</span>
        <span class="keyword">function</span> fqfn     = matFqfn(pth, pre, post)
            assert(lexist(pth, <span class="string">'dir'</span>));
            <span class="keyword">if</span> (isempty(strfind(post, <span class="string">'.mat'</span>))); post = [post <span class="string">'.mat'</span>]; <span class="keyword">end</span>
            fqfn = fullfile(pth, [pre mlfsl.FlirtFacade.FLIRT_TOKEN post]);
        <span class="keyword">end</span>
        <span class="keyword">function</span>            prepareRoisOnT1(bldr)

            import <span class="string">mlfourd.*</span> <span class="string">mlfsl.*</span>;
            rois   = RoiFactory.ROIS;
            flirtf = FlirtFacade(bldr);
            msg    = <span class="string">''</span>;
            <span class="keyword">for</span> r = 2:numel(rois) <span class="comment">%#ok&lt;*FORFLG&gt;</span>
                <span class="keyword">try</span>
                     opts.ref  = flirtf.t1;
                     opts.in   = fullfile(flirtf.atlasPath, RoiFactory.ATLASES{r});
                     opts.out  = RoiFactory.onT1(rois{r});
                     opts.init = fullfile(bldr.transformationsPath, [<span class="string">'MNI'</span> mlfsl.FlirtFacade.FLIRT_TOKEN <span class="string">'t1.mat'</span>]);
                    [~,msg]    = flirtf.applyxfm(opts); <span class="comment">%#ok&lt;*PFTIN&gt;</span>
                <span class="keyword">catch</span> ME
                    handexcept(ME, msg)
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span> <span class="comment">% static prepareRoisOnT1</span>
        <span class="keyword">function</span>            prepareModelok(bldr)
            import <span class="string">mlfourd.*</span> <span class="string">mlfsl.*</span>;
            flirtf             = FlirtFacade(bldr);
            cbf_asl1           = NIfTI.load(<span class="string">'cbf_asl1'</span>);
            modelok            = (cbf_asl1 &gt; 1) &amp; (cbf_asl1 &lt; 120);
            modelok.fileprefix = <span class="string">'modelok'</span>;
            modelok.save;
            msg                = <span class="string">''</span>;
            <span class="keyword">try</span>
                 opts.ref  = flirtf.t1;
                 opts.in   = <span class="string">'modelok'</span>;
                 opts.out  = RoiFactory.onT1(<span class="string">'modelok'</span>);
                 opts.init = fullfile(bldr.transformationsPath, [<span class="string">'asl1'</span> mlfsl.FlirtFacade.FLIRT_TOKEN <span class="string">'t1.mat'</span>]);
                [~,msg]    = flirtf.applyxfm(opts); <span class="comment">%#ok&lt;NASGU&gt;</span>
            <span class="keyword">catch</span> ME
                handexcept(ME, msg)
            <span class="keyword">end</span>
        <span class="keyword">end</span> <span class="comment">% static prepareModelok</span>
        <span class="keyword">function</span>            registerToModalities(bldr)
</pre><h2>REGISTERTOMODALITIES<a name="13"></a></h2><pre>theRois should be preregistered onto MPRAGE; done on filesystem with fsl; combine from there---</pre><pre class="codeinput">            import <span class="string">mlfourd.*</span> <span class="string">mlfsl.*</span>;
            modes  = RoiFactory.MODES;
            rois   = RoiFactory.ROIS;  <span class="comment">%#ok&lt;*PROP&gt;</span>
            flirtf = FlirtFacade(bldr);
            msg    = <span class="string">''</span>;
            <span class="keyword">for</span> r = 1:length(rois) <span class="comment">%#ok&lt;PROP&gt;</span>
                <span class="keyword">if</span> (strcmp(rois{r}, <span class="string">'white'</span>))
                    trimroi(RoiFactory.onT1(rois{r}), <span class="keyword">...</span>
                           {RoiFactory.onT1(rois{4}) RoiFactory.onT1(rois{5})});
                <span class="keyword">end</span>
                <span class="keyword">for</span> m = 1:length(modes)
                    <span class="keyword">try</span>
                        [~,msg] =         copyfile(RoiFactory.t1ToMode(          modes{m}), <span class="keyword">...</span>
                                                   RoiFactory.roiToMode(rois{r}, modes{m}), <span class="string">'f'</span>); <span class="comment">%#ok&lt;PROP&gt;</span>
                         opts.ref  = RoiFactory.theMetrics{m};
                         opts.in   = RoiFactory.onT1(     rois{r});
                         opts.out  = RoiFactory.roiOnMode(rois{r}, modes{m});
                         opts.init = RoiFactory.inits(    rois{r}, modes{m});
                        [~,msg]    = flirtf.applyxfm(     opts); <span class="comment">%#ok&lt;PROP&gt;</span>

                    <span class="keyword">catch</span> ME
                        handexcept(ME, msg);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span> <span class="comment">% static registerToModalities</span>

        <span class="keyword">function</span> fp = onT1(roi)
            import <span class="string">mlfourd.*</span>;
            fp = [roi mlfsl.FlirtFacade.FLIRT_TOKEN <span class="string">'t1'</span>];
        <span class="keyword">end</span>
        <span class="keyword">function</span> fn = roiToT1(roi, bldr)
            import <span class="string">mlfourd.*</span>;
            tp = bldr.transformationsPath;
            fn = fullfile(tp, [roi mlfsl.FlirtFacade.FLIRT_TOKEN <span class="string">'t1.mat'</span>]);
        <span class="keyword">end</span>
        <span class="keyword">function</span> fn = t1ToMode(mode, bldr)
            import <span class="string">mlfourd.*</span>;
            fn = fullfile(bldr.transformationsPath, [<span class="string">'t1'</span> mlfsl.FlirtFacade.FLIRT_TOKEN mode <span class="string">'.mat'</span>]);
        <span class="keyword">end</span>
        <span class="keyword">function</span> fn = roiToMode(roi, mode, bldr)
            import <span class="string">mlfourd.*</span>;
            fn = fullfile(bldr.transformationsPath, [roi mlfsl.FlirtFacade.FLIRT_TOKEN mode <span class="string">'.mat'</span>]);
        <span class="keyword">end</span>
        <span class="keyword">function</span> ms = theMetrics
            import <span class="string">mlfourd.*</span>;
            ms = cell(size(RoiFactory.MODES));
            <span class="keyword">for</span> m = 1:length(RoiFactory.MODES)
                ms{m} = [<span class="string">'cbf_'</span> RoiFactory.MODES{m}];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> fp = roiOnMode(roi, mode)
            import <span class="string">mlfourd.*</span>;
            fp = [roi mlfsl.FlirtFacade.FLIRT_TOKEN mode];
        <span class="keyword">end</span>
        <span class="keyword">function</span> fn = inits(roi, mode, bldr)
            import <span class="string">mlfourd.*</span>;
            fn = fullfile(bldr.transformationsPath,[roi mlfsl.FlirtFacade.FLIRT_TOKEN mode <span class="string">'.mat'</span>]);
        <span class="keyword">end</span>

        <span class="keyword">function</span> [metrics,rois] = assembleModalRois(andContinue)

            import <span class="string">mlfourd.*</span>;
            rf      = RoiFactory;
            modes   = rf.MODES;
            nModes  = numel(modes);

            <span class="keyword">if</span> (lexist(  <span class="string">'modelok.nii.gz'</span>,<span class="string">'file'</span>))
                copyfile(<span class="string">'modelok.nii.gz'</span>, [<span class="string">'modelok'</span> mlfsl.FlirtFacade.FLIRT_TOKEN <span class="string">'asl1.nii.gz'</span>], <span class="string">'f'</span>);
            <span class="keyword">end</span>
            rois    = cell(numel(rf.ROIS), nModes);
            <span class="keyword">for</span> r = 1:numel(rf.ROIS)
                <span class="keyword">for</span> m = 1:nModes
                    rois{r,m} = NIfTI.load([rf.ROIS{r} mlfsl.FlirtFacade.FLIRT_TOKEN rf.MODES{m}]);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            metrics    = RoiFactory.toNIfTI( <span class="keyword">...</span>
                         arrayfun(@(str) [<span class="string">'cbf_'</span> char(str)], rf.MODES, <span class="string">'UniformOutput'</span>, false));
            assert(lstrfind(metrics{2}.label, <span class="string">'asl'</span>));
            aslImg     = metrics{2}.img;
            metrics{2}.img = aslImg .* (aslImg &gt; 1) .* (aslImg &lt; 120); <span class="comment">% KLUDGE to bound ASL</span>

            <span class="keyword">if</span> (exist(<span class="string">'andContinue'</span>,<span class="string">'var'</span>) &amp;&amp; andContinue)
                movefile(<span class="string">'assembleModalRois.txt'</span>, <span class="string">'assembleModalRois.bak'</span>, <span class="string">'f'</span>);
                diary(   <span class="string">'assembleModalRois.txt'</span>);
                [metrics, modelOks, parenchymas, mcas, grays, deepgrays, whites, lefts, rights, Cerebellums] = <span class="keyword">...</span>
                RoiFactory.tabulateModalRois( <span class="keyword">...</span>
                    metrics, <span class="keyword">...</span>
                    slicecell(rois,1), slicecell(rois,2), slicecell(rois,3), slicecell(rois,4), slicecell(rois,5), <span class="keyword">...</span>
                    slicecell(rois,6), slicecell(rois,7), slicecell(rois,8), slicecell(rois,9));
                diary <span class="string">off</span>;
                <span class="keyword">for</span> m = 1:numel(rf.MODES) <span class="comment">%#ok&lt;FORFLG&gt;</span>
                    rois{1,m} = metrics{m} .* (parenchymas{m} + modelOks{m});
                    rois{2,m} = metrics{m} .*  parenchymas{m};
                    rois{3,m} = metrics{m} .* (parenchymas{m} + mcas{m});
                    rois{4,m} = metrics{m} .* (parenchymas{m} + grays{m});
                    rois{5,m} = metrics{m} .* (parenchymas{m} + deepgrays{m});
                    rois{6,m} = metrics{m} .* (parenchymas{m} + whites{m});
                    rois{7,m} = metrics{m} .* (parenchymas{m} + lefts{m});
                    rois{8,m} = metrics{m} .* (parenchymas{m} + rights{m});
                    rois{9,m} = metrics{m} .* (parenchymas{m} + Cerebellums{m});
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span> <span class="comment">% assembleModalRois</span>
        <span class="keyword">function</span> [metrics, modelOks, parenchymas, mcas, grays, deepgrays, whites, lefts, rights, Cerebellums] = <span class="keyword">...</span>
                       tabulateModalRois(metrics, modelOks, parenchymas, mcas, grays, deepgrays, whites, lefts, rights, Cerebellums)
</pre><h2>TABULATEMODALROIS displays a table of cell-array metrics<a name="16"></a></h2><pre>as evaluated by row over ROIs for ASL-model-limits, no-CSF, MCA territory, ipsilateral hemisphere,
cortical tissue, deep basal ganglia, white matter.   Metrics is evaluated by columns over the
various imaging modalities, e.g., PET, ASL, DSC, LAIF
See also:   assembleModalRois</pre><pre class="codeinput">            import <span class="string">mlfourd.*</span>;
            fprintf(<span class="string">'RoiFactory.tabulateModalRois:\n'</span>);
</pre><h2>prepare all inputs as RoiFactories<a name="17"></a></h2><pre class="codeinput">            metrics     = RoiFactory.toNIfTI(metrics);
            modelOks    = RoiFactory.toNIfTI(modelOks);
            parenchymas = RoiFactory.toNIfTI(parenchymas);
            mcas        = RoiFactory.toNIfTI(mcas);
            grays       = RoiFactory.toNIfTI(grays);
            deepgrays   = RoiFactory.toNIfTI(deepgrays);
            whites      = RoiFactory.toNIfTI(whites);
            lefts       = RoiFactory.toNIfTI(lefts);
            rights      = RoiFactory.toNIfTI(rights);
            Cerebellums = RoiFactory.toNIfTI(Cerebellums);

            <span class="keyword">for</span> m = 1:length(grays)
                grays{m} = grays{m} + whites{m};
                gtone    = grays{m} &gt; 1;
                grays{m} = grays{m} .* (~gtone) + gtone;
                grays{m}.fileprefix = [<span class="string">'cortical'</span> mlfsl.FlirtFacade.FLIRT_TOKEN RoiFactory.MODES{m}];
                grays{m}.save;
            <span class="keyword">end</span>



            <span class="comment">% permutations will be with fg, tissue, hemisphere RoiFactories</span>
            <span class="comment">% each modality gets separate, m-indexe RoiFactories</span>
            nModes           = length(metrics);
            metricFactories  = cell(1,nModes);
            modelokFactories = cell(1,nModes);
            mcaFactories     = cell(1,nModes);
            fgFactories      = cell(1,nModes);
            ipsiFactories    = cell(1,nModes);
            contraFactories  = cell(1,nModes);
            grayFactories    = cell(1,nModes);
            deepFactories    = cell(1,nModes);
            whiteFactories   = cell(1,nModes);
            bellumFactories  = cell(1,nModes);
</pre><h2>prepare rescaled metrics<a name="18"></a></h2><pre class="codeinput">            ho15MeanVoxels = nan;
            <span class="keyword">for</span> m = 1:nModes

                metricFactories{m} = RoiFactory(metrics{m}, parenchymas{m} .* mcas{m} .* rights{m} .* whites{m});
                <span class="keyword">switch</span> (m)
                    <span class="keyword">case</span> 1
                        ho15MeanVoxels    = metricFactories{1}.meanVoxels;
                        ho15MeanVoxels    = ho15MeanVoxels{1};
                    <span class="keyword">case</span> {3,4}
                        metricFactories{m}.roiLabels = {<span class="string">'contraNormalWhite'</span>};
                        metricFactories{m} = metricFactories{m}.rescaleByReference(metricFactories{m}.theRois{1}, <span class="keyword">...</span>
                                                                                   ho15MeanVoxels);
                        metrics{m}         = metricFactories{m}.theMetric;
                <span class="keyword">end</span>
                metricFactories{m}.printStats;
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n\n'</span>);
</pre><h2>initialize modelOks, mcas, fg<a name="19"></a></h2><pre class="codeinput">            <span class="keyword">for</span> m = 1:nModes
                fg             = modelOks{m} .* parenchymas{m} .* mcas{m};
                fg.fileprefix  = <span class="string">'fg'</span>;
                modelokFactories{m} = RoiFactory(metrics{m}, modelOks{m} .* parenchymas{m});
                modelokFactories{m}.roiLabels = repmat({<span class="string">'modelOk'</span>}, size(modelokFactories{m}.roiLabels));
                modelokFactories{m}.printStats(<span class="string">'modelok'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                fg             = modelOks{m} .* parenchymas{m} .* mcas{m};
                fg.fileprefix  = <span class="string">'fg'</span>;
                mcaFactories{m} = RoiFactory(metrics{m}, mcas{m} .* modelOks{m});
                mcaFactories{m}.roiLabels = repmat({<span class="string">'mca'</span>}, size(mcaFactories{m}.roiLabels));
                mcaFactories{m}.printStats(<span class="string">'mca'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                fg             = modelOks{m} .* parenchymas{m} .* mcas{m};
                fg.fileprefix  = <span class="string">'fg'</span>;
                fgFactories{m} = RoiFactory(metrics{m}, fg);
                fgFactories{m}.roiLabels = repmat({<span class="string">'fg'</span>}, size(fgFactories{m}.roiLabels));
                fgFactories{m}.printStats(<span class="string">'fg'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n\n'</span>);
</pre><h2>ipsi(modelOks), contra(modelOks)<a name="20"></a></h2><pre class="codeinput">            fprintf(<span class="string">'modelOks:'</span>);
            <span class="keyword">for</span> m = 1:nModes
                ipsiFactories{m} = RoiFactory(metrics{m}, lefts{m});
                ipsiFactories{m} = ipsiFactories{m}.restrictAllRois(modelokFactories{m});
                ipsiFactories{m}.printStats(lefts{m}.label);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            fprintf(<span class="string">'modelOks:'</span>);
            <span class="keyword">for</span> m = 1:nModes
                contraFactories{m} = RoiFactory(metrics{m}, rights{m});
                contraFactories{m} = contraFactories{m}.restrictAllRois(modelokFactories{m});
                contraFactories{m}.printStats(rights{m}.label);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n\n'</span>);
</pre><h2>ipsi(mcas), contra(mcas); reset ipsi/contra-factories<a name="21"></a></h2><pre class="codeinput">            fprintf(<span class="string">'mcas:'</span>);
            <span class="keyword">for</span> m = 1:nModes
                ipsiFactories{m} = RoiFactory(metrics{m}, lefts{m});
                ipsiFactories{m} = ipsiFactories{m}.restrictAllRois(mcaFactories{m});
                ipsiFactories{m}.printStats(lefts{m}.label);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            fprintf(<span class="string">'mcas:'</span>);
            <span class="keyword">for</span> m = 1:nModes
                contraFactories{m} = RoiFactory(metrics{m}, rights{m});
                contraFactories{m} = contraFactories{m}.restrictAllRois(mcaFactories{m});
                contraFactories{m}.printStats(rights{m}.label);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n\n'</span>);
</pre><h2>ipsi(fg), contra(fg); reset ipsi/contra-factories<a name="22"></a></h2><pre class="codeinput">            fprintf(<span class="string">'fg:'</span>);
            <span class="keyword">for</span> m = 1:nModes
                ipsiFactories{m} = RoiFactory(metrics{m}, lefts{m});
                ipsiFactories{m} = ipsiFactories{m}.restrictAllRois(fgFactories{m});
                ipsiFactories{m}.printStats(lefts{m}.label);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            fprintf(<span class="string">'fg:'</span>);
            <span class="keyword">for</span> m = 1:nModes
                contraFactories{m} = RoiFactory(metrics{m}, rights{m});
                contraFactories{m} = contraFactories{m}.restrictAllRois(fgFactories{m});
                contraFactories{m}.printStats(rights{m}.label);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n\n'</span>);
</pre><h2>gray(fg), deep(fg), white(fg), bellum(fg); reset factories<a name="23"></a></h2><pre class="codeinput">            <span class="keyword">for</span> m = 1:nModes
                  grayFactories{m} = RoiFactory(metrics{m}, grays{m});
                  grayFactories{m} = grayFactories{m}.restrictAllRois(fgFactories{m});
                  grayFactories{m}.printStats(grays{m}.label, <span class="string">'fg'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                  deepFactories{m} = RoiFactory(metrics{m}, deepgrays{m});
                  deepFactories{m} = deepFactories{m}.restrictAllRois(fgFactories{m});
                  deepFactories{m}.printStats(deepgrays{m}.label, <span class="string">'fg'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                 whiteFactories{m} = RoiFactory(metrics{m}, whites{m});
                 whiteFactories{m} = whiteFactories{m}.restrictAllRois(fgFactories{m});
                 whiteFactories{m}.printStats(whites{m}.label, <span class="string">'fg'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                bellumFactories{m} = RoiFactory(metrics{m}, Cerebellums{m});
                bellumFactories{m} = bellumFactories{m}.restrictAllRois(fgFactories{m});
                bellumFactories{m}.printStats(Cerebellums{m}.label, <span class="string">'fg'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n\n'</span>);
</pre><h2>gray(ipsi), deep(ipsi), white(ipsi), bellum(ipsi); reset factories<a name="24"></a></h2><pre class="codeinput">            <span class="keyword">for</span> m = 1:nModes
                  grayFactories{m} = RoiFactory(metrics{m}, grays{m});
                  grayFactories{m} = grayFactories{m}.restrictAllRois(ipsiFactories{m});
                  grayFactories{m}.printStats(grays{m}.label, <span class="string">'ipsi'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                  deepFactories{m} = RoiFactory(metrics{m}, deepgrays{m});
                  deepFactories{m} = deepFactories{m}.restrictAllRois(ipsiFactories{m});
                  deepFactories{m}.printStats(deepgrays{m}.label, <span class="string">'ipsi'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                 whiteFactories{m} = RoiFactory(metrics{m}, whites{m});
                 whiteFactories{m} = whiteFactories{m}.restrictAllRois(ipsiFactories{m});
                 whiteFactories{m}.printStats(whites{m}.label, <span class="string">'ipsi'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                bellumFactories{m} = RoiFactory(metrics{m}, Cerebellums{m});
                bellumFactories{m} = bellumFactories{m}.restrictAllRois(ipsiFactories{m});
                bellumFactories{m}.printStats(Cerebellums{m}.label, <span class="string">'ipsi'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n\n'</span>);
</pre><h2>gray(contra), deep(contra), white(contra), bellum(contra); reset factories<a name="25"></a></h2><pre class="codeinput">            <span class="keyword">for</span> m = 1:nModes
                  grayFactories{m} = RoiFactory(metrics{m}, grays{m});
                  grayFactories{m} = grayFactories{m}.restrictAllRois(contraFactories{m});
                  grayFactories{m}.printStats(grays{m}.label, <span class="string">'contra'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                  deepFactories{m} = RoiFactory(metrics{m}, deepgrays{m});
                  deepFactories{m} = deepFactories{m}.restrictAllRois(contraFactories{m});
                  deepFactories{m}.printStats(deepgrays{m}.label, <span class="string">'contra'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                 whiteFactories{m} = RoiFactory(metrics{m}, whites{m});
                 whiteFactories{m} = whiteFactories{m}.restrictAllRois(contraFactories{m});
                 whiteFactories{m}.printStats(whites{m}.label, <span class="string">'contra'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n'</span>);
            <span class="keyword">for</span> m = 1:nModes
                bellumFactories{m} = RoiFactory(metrics{m}, Cerebellums{m});
                bellumFactories{m} = bellumFactories{m}.restrictAllRois(contraFactories{m});
                bellumFactories{m}.printStats(Cerebellums{m}.label, <span class="string">'contra'</span>);
            <span class="keyword">end</span>
            fprintf(<span class="string">'\n\n'</span>);
</pre><pre class="codeinput">        <span class="keyword">end</span> <span class="comment">% tabulateModalRois</span>
        <span class="keyword">function</span> fp  = toFileprefix(nii)
</pre><h2>TOFILEPREFIX converts fileprefixes or NIfTIs to well-formed fileprefixes<a name="28"></a></h2><pre class="codeinput">            import <span class="string">mlfourd.*</span>;
            <span class="keyword">if</span> (iscell(nii))
                fp = cell(1,length(nii));
                <span class="keyword">for</span> f = 1:length(nii)
                    fp{f} = RoiFactory.toNIfTI(nii{f});
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                <span class="keyword">if</span> (isa(nii, <span class="string">'mlfourd.ImageInterface'</span>))
                    fp = nii.fileprefix;
                <span class="keyword">elseif</span> (ischar(nii))
                    fp = fileprefix(nii);
                <span class="keyword">else</span>
                    error(<span class="string">'mlfourd:UnsupportedType'</span>, <span class="string">'class(nii)-&gt;%s'</span>, class(nii));
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>
        <span class="keyword">function</span> nii = toNIfTI(fp)
</pre><h2>TONIFTI converts fileprefixes or NIfTIs to well-formed NIfTIs<a name="31"></a></h2><pre class="codeinput">            import <span class="string">mlfourd.*</span>;
            <span class="keyword">if</span> (iscell(fp))
                nii = cell(1,length(fp));
                <span class="keyword">for</span> f = 1:length(fp)
                    nii{f} = RoiFactory.toNIfTI(fp{f});
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                <span class="keyword">if</span> (ischar(fp))
                    nii = NIfTI.load(fp);
                <span class="keyword">elseif</span> (isa(fp, <span class="string">'mlfourd.ImageInterface'</span>))
                    nii = NIfTI(fp);
                <span class="keyword">elseif</span> (isa(fp, <span class="string">'mlfourd.RoiFactory'</span>))
                    nii = NIfTI(fp.intersectionRois);
                <span class="keyword">else</span>
                    error(<span class="string">'mlfourd:UnsupportedType'</span>, <span class="string">'class(fp)-&gt;%s'</span>, class(fp));
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% static methods</span>



    methods
        <span class="keyword">function</span> lbl  = get.metricLabel(this)
            lbl = this.theMetric.label;
        <span class="keyword">end</span>
        <span class="keyword">function</span> lbls = get.roiLabels(this)
            Nrois = numel(this.theRois);
            lbls  = cell(1,Nrois);
            <span class="keyword">for</span> r = 1:Nrois
                lbls{r} = this.theRois{r}.label;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> this = set.roiLabels(this, lbls)
            Nrois = numel(this.theRois);
            assert(Nrois == length(lbls));
            <span class="keyword">for</span> r = 1:Nrois
                this.theRois{r}.label = lbls{r};
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> vecs = sampleVoxels(this, choice)
</pre><h2>SAMPLEVOXELS samples metric-voxels with some or all internal ROIs<a name="34"></a></h2><pre class="codeinput">            import <span class="string">mlfourd.*</span>;
            niib = NiiBrowser(this.theMetric);
            <span class="keyword">switch</span> (nargin)
                <span class="keyword">case</span> 1
                    vecs = cell(1,length(this.theRois));
                    <span class="keyword">for</span> v = 1:length(vecs)
                        vecs{v} = niib.sampleVoxels(this.theRois{v});
                    <span class="keyword">end</span>
                <span class="keyword">case</span> 2
                    v = 1;
                    <span class="keyword">if</span> (ischar(choice))
                        <span class="keyword">for</span> r = 1:length(this.theRois)
                            <span class="keyword">if</span> (lstrfind(this.theRois{r}.label, choice))
                                v = r; <span class="keyword">break</span>;
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">else</span>
                        assert(isnumeric(choice));
                        v = choice;
                    <span class="keyword">end</span>
                    vecs = { niib.sampleVoxels(this.theRois{v})};
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span> <span class="comment">% sampleVoxels</span>
        <span class="keyword">function</span> n    = nVoxels(this, choice)
            <span class="keyword">switch</span> (nargin)
                <span class="keyword">case</span> 1
                    sv = this.sampleVoxels;
                <span class="keyword">case</span> 2
                    sv = this.sampleVoxels(choice);
            <span class="keyword">end</span>
            <span class="keyword">if</span> (~iscell(sv)); sv = {sv}; <span class="keyword">end</span>
            n = cell(1,length(sv));
            <span class="keyword">for</span> nidx = 1:numel(n)
                n{nidx} = numel(sv{nidx});
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> m    = meanVoxels(this, choice)
            <span class="keyword">switch</span> (nargin)
                <span class="keyword">case</span> 1
                    sv = this.sampleVoxels;
                <span class="keyword">case</span> 2
                    sv = this.sampleVoxels(choice);
            <span class="keyword">end</span>
            m = cell(size(sv));
            <span class="keyword">for</span> midx = 1:numel(m)
                m{midx} = mean(sv{midx});
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> s    = stdVoxels(this, choice)
            sv = this.sampleVoxels(choice);
            <span class="keyword">if</span> (iscell(sv)); sv = sv{1}; <span class="keyword">end</span>
            s = std(sv);
        <span class="keyword">end</span>
        <span class="keyword">function</span>        printStats(this, choice, lbl)
            chstr = 1;
            <span class="keyword">if</span> (nargin &gt; 1)
                <span class="keyword">if</span> (isnumeric(choice))
                    chstr = [<span class="string">'roi#'</span> num2str(choice)];
                <span class="keyword">else</span>
                    chstr = char(choice);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> (nargin &gt; 2)
                chstr = [chstr <span class="string">'(x)'</span> lbl];
            <span class="keyword">end</span>
            fprintf(<span class="string">'%s(x)%s: \t %s \t %s \t %s; \t'</span>, <span class="keyword">...</span>
                this.metricLabel, chstr, <span class="keyword">...</span>
                cell2str(this.nVoxels(   chstr)), <span class="keyword">...</span>
                cell2str(this.meanVoxels(chstr)), <span class="keyword">...</span>
                cell2str(this.stdVoxels( chstr)));
        <span class="keyword">end</span>
    <span class="keyword">end</span>



    methods (Access = <span class="string">'protected'</span>)

        <span class="keyword">function</span> this = RoiFactory(metric, rois)
</pre><h2>CTOR<a name="37"></a></h2><pre>Usage: this = mlfourd.RoiFactory(metric [, rois])
       ^ factory                 ^         ^ fileprefixes or NIfTIs</pre><pre class="codeinput">            import <span class="string">mlfourd.*</span>;
            <span class="keyword">if</span> (nargin &gt; 0)
                this.theMetric = RoiFactory.toNIfTI(metric);
            <span class="keyword">end</span>
            <span class="keyword">if</span> (nargin &gt; 1)
                <span class="keyword">if</span> (~iscell(rois)); rois = {rois}; <span class="keyword">end</span>;
                this.theRois = RoiFactory.toNIfTI(rois);
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span> <span class="comment">% ctor</span>



        <span class="keyword">function</span> this = load(this, object)
</pre><h2>LOAD appends object, converted to NIfTI, to this.theRois<a name="40"></a></h2><pre class="codeinput">            import <span class="string">mlfourd.*</span>;
            nNiis0 = length(this.theRois);
            <span class="keyword">if</span> (~iscell(object)); object = {object}; <span class="keyword">end</span>
            <span class="keyword">for</span> o = 1:length(object)
                this.theRois{nNiis0 + o} = RoiFactory.toNIfTI(object{o});
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span> <span class="comment">% load</span>
        <span class="keyword">function</span> this = restrictAllRois(this, fg)

            import <span class="string">mlfourd.*</span>;
            fg = RoiFactory.toNIfTI(fg);
            <span class="keyword">for</span> n = 1:length(this.theRois)
                tmp = this.theRois{n};
                tmp = fg .* tmp;
                tmp.fileprefix = [fg.fileprefix <span class="string">'(x)'</span> this.theRois{n}.fileprefix];
                this.theRois{n} = tmp;
            <span class="keyword">end</span>
        <span class="keyword">end</span> <span class="comment">% restrictAllRois</span>
        <span class="keyword">function</span> iroi = intersectionRois(this)
            iroi = this.theMetric.ones;
            <span class="keyword">for</span> r = 1:length(this.theRois)
                iroi = iroi .* this.theRois{r};
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> this = intersectNbyM(this, miis)
</pre><h2>INTERSECTNBYM intersects all this.theRois with the intersection of all miis,<a name="43"></a></h2><pre>placing the product of intersections back in this.theRois</pre><pre class="codeinput">            import <span class="string">mlfourd.*</span>;
            <span class="keyword">if</span> (~iscell(miis)); miis = {miis}; <span class="keyword">end</span>;
            <span class="keyword">for</span> n = 1:length(this.theRois)
                <span class="keyword">for</span> m = 1:length(miis)
                    miis{m} = RoiFactory.toNIfTI(miis{m});
                    tmp = this.theRois{n};
                    tmp = miis{m} .* tmp;
                    tmp.fileprefix = [miis{m}.fileprefix <span class="string">'(x)'</span> this.theRois{n}.fileprefix];
                    this.theRois{n} = tmp;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">end</span>  <span class="comment">% intersectNbyM</span>
        <span class="keyword">function</span> this = rescaleByReference(this, refRoi, refMean)
</pre><h2>RESCALEBYREFERENCE<a name="46"></a></h2><pre class="codeinput">            import <span class="string">mlfourd.*</span>;
            metricb     = NiiBrowser(this.theMetric);
            metricMean  = mean(metricb.sampleVoxels(refRoi));
            this.theMetric = this.theMetric .* (refMean/metricMean);
            this.theMetric.fileprefix = [this.theMetric.fileprefix <span class="string">'_scaled2ref'</span>];
</pre><pre class="codeinput">        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% methods</span>
</pre><pre class="codeinput"><span class="keyword">end</span> <span class="comment">% classdef RoiFactory</span>
</pre><pre class="codeoutput">The class mlfsl.FslFacade has no property or method named 'TOKEN'.
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
classdef RoiFactory
    
    %% ROIFACTORY creates ROIs, reads from and writes to a filesystem.
    %
    %  Created by John Lee on 2009-01-27.
    %  Copyright (c) 2009 Washington University School of Medicine.  All rights reserved.
    %  Report bugs to <email = "bugs.perfusion.neuroimage.wustl.edu@gmail.com"/>.
    %
    properties (Constant)
        MODES   = { 'ho15'    'asl1'       'ssvd'}; % 'bip' };
        ROIS    = { 'modelok' 'parenchyma' 'mca'  'pca' 'gray' 'deepgray' 'white' 'left' 'right' 'Cerebellum' };
        ATLASES = { '' ...
                    'parenchyma-sub-maxprob-thr25-2mm' ...
                    'MNI152_T1_2mm_JoshsMCA_bilat' ...
                    'MNI152_T1_2mm_PCA_bilat' ...
                          'gray-sub-maxprob-thr25-2mm' ...
                      'deepgray-sub-maxprob-thr25-2mm' ...
                         'white-sub-maxprob-thr25-2mm' ...
                         'left-MNI152-2mm' ...
                        'right-MNI152-2mm' ...
               'Cerebellum-MNIfnirt-maxprob-thr25-2mm' };
        EP2D    = 'ep2d'; % 'ep2d2'
        TOKEN   = mlfsl.FslFacade.TOKEN;
    end
    
    properties (SetAccess = 'protected')
        theMetric
        theRois % cell-array of NIfTIs
    end
    
    properties (Dependent)
        metricLabel
        roiLabels
    end
    
    
    
    methods (Static)
            
        function   binnii = threshRoiByStd(fpmsk, numstd)
        
            %% THRESHOLDROIBYSTD determines a statistical threshold for a floating-point mask
            %                    and uses that threshold to generate a binary mask;
            %                    uses a multiplier for std
            %  Usage:  binnii = mlfourd.RoiFactory.threshRoiByStd(fpmsk, numstd)
            %          numstd:  set threshold to be max intensity - numstd*std (optional)
            %                   otherwise mask coverage will be set to 1 percent of voxels
            %  OBSOLETE, DEPRECATED
            mlfourd.NIfTI.isNIfTI
            maxfp  = dipmax(fpmsk.img);
            stdfp  = dipstd(fpmsk.img);
            switch (nargin)
                case 1
                    thresh = maxfp;
                    for n = 1:floor(maxfp/stdfp) 
                        thresh   = thresh - stdfp;
                        coverage = dipsum(double(fpmsk.img > thresh))/ ...
                                   dipprod(fpmsk.hdr.dime.dim(2:4)); 
                        if (coverage > 0.01)
                            break;
                        end
                    end    
                case 2
                    thresh = maxfp - numstd*stdfp;
                otherwise
                    error('mlfourd:InputParamsErr', ...
                         ['RoiFactory.threshRoiByStd does not support ' num2str(nargin) ' input params']);
            end
            bin    = double(fpmsk.img > thresh);
            binnii = fpmsk.makeSimilar(bin, 'RoiFactory.threshRoiByStd'); 
            disp(['RoiFactory.threshRoiByStd.maxfp -> ' num2str(maxfp)]);
            disp(['                        stdfp -> ' num2str(stdfp)]);
            disp(['                       thresh -> ' num2str(thresh)]);
        end % static threshRoiByStd
        function   binnii = threshRoiByCoverage(fpmsk, cover)
            
            %% Static  THRESHOLDROI_COVERAGE determines a statistical threshold for 
            %          a floating-point mask and uses that threshold to generate a binary mask;
            %          uses a fractional coverage parameter
            %  Usage:  binnii = mlfourd.RoiFactory.threshRoiByCoverage(fpmsk, cover)
            %          numstd:  set threshold to be max intensity - numstd*std (optional)
            %                   otherwise mask coverage will be set to 1 percent of voxels
            %  OBSOLETE, DEPRECATED
            mlfourd.NIfTI.isNIfTI
            maxfp  = dipmax(fpmsk.img);
            stdfp  = dipstd(fpmsk.img);
            if (1 == nargin); cover = 0.00667; end
            if (nargin < 1 || nargin > 2)
                error('mlfourd:InputParamsErr', ...
                     ['RoiFactory.threshRoiByStd does not support ' ...
                       num2str(nargin) ' input params']);
            end
            thresh = maxfp;
            for n = 1:floor(maxfp/stdfp) 
                thresh   = thresh - stdfp;
                coverage = dipsum(double(fpmsk.img > thresh))/ ...
                           dipprod(fpmsk.hdr.dime.dim(2:4)); 
                if (coverage > cover)
                    break;
                end
            end
            bin    = double(fpmsk.img > thresh);
            binnii = fpmsk.makeSimilar(bin, 'RoiFactory.threshRoiByStd'); 
            disp(['RoiFactory.threshRoiByStd.maxfp -> ' num2str(maxfp)]);
            disp(['                          stdfp -> ' num2str(stdfp)]);
            disp(['                         thresh -> ' num2str(thresh)]);
        end % static threshRoiByCoverage        
        function   nii    = makeArteryRoi(epinii, fgnii)
                       
            %% MAKEARTERIESROI constructs a probability map of arteries from DSC data
            %  Usage:  nii = mlfourd.RoiFactory.makeArteryRoi(epinii, fgnii)
            %  Requires:  diplib
            %
            assert(mlfourd.NIfTI.isNIfTI(epinii));
            assert(mlfourd.NIfTI.isNIfTI(fgnii));
            assert(4 == size(size(epinii.img), 2));                 % assert 4D time-series
            assert(numel(squeeze(epinii.img(:,:,:,1))) == numel(fgnii.img));
            fg = double(squeeze(fgnii.img) > 0);         % binary mask
            
            T_SSTATE       = 4; % frame at which M is in steady-state
            T_BEFORE_BOLUS = 1; % look slightly before the bolus peak 
                                % to avoid saturation effects, adjustable
            T_LAST         = size(epinii.img, 4);
                                
            % determine time of bolus-passage, tBolus
            epiImg = double(epinii.img(:,:,:,T_SSTATE:T_LAST-T_SSTATE));
            epimip = zeros(size(epiImg, 4), 1);
            for t = 1:size(epiImg, 4)
                epimip(t) = dipsum(squeeze(epiImg(:,:,:,t)) .* fg);
            end
            tBolus = indexOfMin(epimip);
            
            % estimate the bolus width from <t - <t>>
            distr      = epimip - epimip(tBolus);
            distr      = max(epimip) - distr;
            times      = (0:length(epimip) - 1)';
            sumdistr   = sum(distr);
            if (sumdistr < eps); sumdistr = 1; end
            bolusWidth = sum(distr .* times)/sumdistr;
            
            
            % estimate the baseline EPI image
            if (bolusWidth/2 < T_BEFORE_BOLUS)
                T_BEFORE_BOLUS = floor(bolusWidth/2); end
            tfBaseline = floor(tBolus - T_BEFORE_BOLUS - bolusWidth/2);  
            if (tfBaseline < T_SSTATE)
                tfBaseline = T_SSTATE; end
            epiBaseline = zeros(size(fg));
            for t = T_SSTATE:tfBaseline
                epiBaseline = epiBaseline + ...
                    squeeze(epiImg(:,:,:,t))/(tfBaseline - T_SSTATE + 1);
            end        
            
            % assemble arteries ROI as NIfTI
            arteries = epiBaseline/refValue(epiBaseline) - ...
                       squeeze( epiImg(:,:,:,tBolus-T_BEFORE_BOLUS)/ ...
                       refValue(epiImg(:,:,:,tBolus-T_BEFORE_BOLUS)));
            msk      = (arteries > eps) .* fg;
            arteries = msk.*arteries/dipsum(msk.*arteries); 
                       % normalize image values to be probabilities
            nii      = fgnii.makeSimilar( ...
                       arteries, 'from RoiFactory.make_arteriesRois');
            
            function val = refValue(img)
                val = mode( ...
                                mlfourd.NiiBrowser.makeSampleVoxels( ...
                                img, double(img > eps)));
            end
        end % static makeArteryRoi
        
        function            prepareMatrices(bldr)
            import mlfsl.* mlfourd.*;
            tpth   = bldr.transformationsPath;
            flirtf = FlirtFacade(bldr);
            
            iopts.inverse = matFqfn(tpth, 'bt1_rot', 'MNI_brain.mat');
            flirtf.invertxfm(iopts);
            copyfile(              matFqfn(tpth,  't1_rot', 'hosum_rot_susan5p52mm.mat'),  matFqfn(tpth, 't1', 'ho15.mat'));
            copyfile(matFqfn(tpth, 'bpasl_rot_mcf_meanvol', 'bt1_rot.mat'),                matFqfn(tpth, 'asl1', 't1.mat'));
            
            iopts.inverse = matFqfn(tpth, 'asl1', 't1.mat');
            flirtf.invertxfm(iopts);
            copyfile(              matFqfn(tpth, 'bt1_rot', ['b' RoiFactory.EP2D '_rot_mcf_meanvol.mat']),  ...
                                                                                           matFqfn(tpth, 't1', 'ssvd.mat'));
        end % static prepareMatrices
        function fqfn     = matFqfn(pth, pre, post)
            assert(lexist(pth, 'dir'));
            if (isempty(strfind(post, '.mat'))); post = [post '.mat']; end
            fqfn = fullfile(pth, [pre mlfsl.FlirtFacade.FLIRT_TOKEN post]);
        end
        function            prepareRoisOnT1(bldr)
            
            import mlfourd.* mlfsl.*;
            rois   = RoiFactory.ROIS;
            flirtf = FlirtFacade(bldr);
            msg    = '';
            for r = 2:numel(rois) %#ok<*FORFLG>
                try
                     opts.ref  = flirtf.t1;
                     opts.in   = fullfile(flirtf.atlasPath, RoiFactory.ATLASES{r});
                     opts.out  = RoiFactory.onT1(rois{r});
                     opts.init = fullfile(bldr.transformationsPath, ['MNI' mlfsl.FlirtFacade.FLIRT_TOKEN 't1.mat']);
                    [~,msg]    = flirtf.applyxfm(opts); %#ok<*PFTIN>
                catch ME
                    handexcept(ME, msg)
                end
            end
            
        end % static prepareRoisOnT1
        function            prepareModelok(bldr)
            import mlfourd.* mlfsl.*;
            flirtf             = FlirtFacade(bldr);
            cbf_asl1           = NIfTI.load('cbf_asl1');
            modelok            = (cbf_asl1 > 1) & (cbf_asl1 < 120);
            modelok.fileprefix = 'modelok';
            modelok.save;
            msg                = '';
            try
                 opts.ref  = flirtf.t1;
                 opts.in   = 'modelok';
                 opts.out  = RoiFactory.onT1('modelok');
                 opts.init = fullfile(bldr.transformationsPath, ['asl1' mlfsl.FlirtFacade.FLIRT_TOKEN 't1.mat']);
                [~,msg]    = flirtf.applyxfm(opts); %#ok<NASGU>
            catch ME
                handexcept(ME, msg)
            end
        end % static prepareModelok
        function            registerToModalities(bldr)
            
            %% REGISTERTOMODALITIES
            %  theRois should be preregistered onto MPRAGE; done on filesystem with fsl; combine from thereREPLACE_WITH_DASH_DASH-
            import mlfourd.* mlfsl.*;
            modes  = RoiFactory.MODES;            
            rois   = RoiFactory.ROIS;  %#ok<*PROP>
            flirtf = FlirtFacade(bldr);
            msg    = '';
            for r = 1:length(rois) %#ok<PROP>
                if (strcmp(rois{r}, 'white'))
                    trimroi(RoiFactory.onT1(rois{r}), ...
                           {RoiFactory.onT1(rois{4}) RoiFactory.onT1(rois{5})});
                end
                for m = 1:length(modes)
                    try
                        [~,msg] =         copyfile(RoiFactory.t1ToMode(          modes{m}), ...
                                                   RoiFactory.roiToMode(rois{r}, modes{m}), 'f'); %#ok<PROP>
                         opts.ref  = RoiFactory.theMetrics{m};
                         opts.in   = RoiFactory.onT1(     rois{r});
                         opts.out  = RoiFactory.roiOnMode(rois{r}, modes{m});
                         opts.init = RoiFactory.inits(    rois{r}, modes{m});
                        [~,msg]    = flirtf.applyxfm(     opts); %#ok<PROP>
                        
                    catch ME
                        handexcept(ME, msg);
                    end
                end                
            end
        end % static registerToModalities
         
        function fp = onT1(roi)
            import mlfourd.*;
            fp = [roi mlfsl.FlirtFacade.FLIRT_TOKEN 't1'];
        end
        function fn = roiToT1(roi, bldr)
            import mlfourd.*;
            tp = bldr.transformationsPath;
            fn = fullfile(tp, [roi mlfsl.FlirtFacade.FLIRT_TOKEN 't1.mat']);
        end        
        function fn = t1ToMode(mode, bldr)
            import mlfourd.*;
            fn = fullfile(bldr.transformationsPath, ['t1' mlfsl.FlirtFacade.FLIRT_TOKEN mode '.mat']);
        end        
        function fn = roiToMode(roi, mode, bldr)
            import mlfourd.*;
            fn = fullfile(bldr.transformationsPath, [roi mlfsl.FlirtFacade.FLIRT_TOKEN mode '.mat']);
        end        
        function ms = theMetrics
            import mlfourd.*;
            ms = cell(size(RoiFactory.MODES));
            for m = 1:length(RoiFactory.MODES)
                ms{m} = ['cbf_' RoiFactory.MODES{m}];
            end
        end        
        function fp = roiOnMode(roi, mode)
            import mlfourd.*;
            fp = [roi mlfsl.FlirtFacade.FLIRT_TOKEN mode];
        end        
        function fn = inits(roi, mode, bldr)
            import mlfourd.*;
            fn = fullfile(bldr.transformationsPath,[roi mlfsl.FlirtFacade.FLIRT_TOKEN mode '.mat']);
        end
        
        function [metrics,rois] = assembleModalRois(andContinue)
            
            import mlfourd.*;
            rf      = RoiFactory;
            modes   = rf.MODES;
            nModes  = numel(modes);
            
            if (lexist(  'modelok.nii.gz','file'))
                copyfile('modelok.nii.gz', ['modelok' mlfsl.FlirtFacade.FLIRT_TOKEN 'asl1.nii.gz'], 'f');
            end
            rois    = cell(numel(rf.ROIS), nModes);
            for r = 1:numel(rf.ROIS)
                for m = 1:nModes
                    rois{r,m} = NIfTI.load([rf.ROIS{r} mlfsl.FlirtFacade.FLIRT_TOKEN rf.MODES{m}]);
                end
            end
            
            metrics    = RoiFactory.toNIfTI( ...
                         arrayfun(@(str) ['cbf_' char(str)], rf.MODES, 'UniformOutput', false));
            assert(lstrfind(metrics{2}.label, 'asl'));
            aslImg     = metrics{2}.img;
            metrics{2}.img = aslImg .* (aslImg > 1) .* (aslImg < 120); % KLUDGE to bound ASL
            
            if (exist('andContinue','var') && andContinue)
                movefile('assembleModalRois.txt', 'assembleModalRois.bak', 'f');
                diary(   'assembleModalRois.txt');
                [metrics, modelOks, parenchymas, mcas, grays, deepgrays, whites, lefts, rights, Cerebellums] = ...
                RoiFactory.tabulateModalRois( ...
                    metrics, ...
                    slicecell(rois,1), slicecell(rois,2), slicecell(rois,3), slicecell(rois,4), slicecell(rois,5), ...
                    slicecell(rois,6), slicecell(rois,7), slicecell(rois,8), slicecell(rois,9));
                diary off;
                for m = 1:numel(rf.MODES) %#ok<FORFLG>
                    rois{1,m} = metrics{m} .* (parenchymas{m} + modelOks{m});
                    rois{2,m} = metrics{m} .*  parenchymas{m}; 
                    rois{3,m} = metrics{m} .* (parenchymas{m} + mcas{m});
                    rois{4,m} = metrics{m} .* (parenchymas{m} + grays{m});
                    rois{5,m} = metrics{m} .* (parenchymas{m} + deepgrays{m});
                    rois{6,m} = metrics{m} .* (parenchymas{m} + whites{m});
                    rois{7,m} = metrics{m} .* (parenchymas{m} + lefts{m});
                    rois{8,m} = metrics{m} .* (parenchymas{m} + rights{m});
                    rois{9,m} = metrics{m} .* (parenchymas{m} + Cerebellums{m});
                end
            end
        end % assembleModalRois
        function [metrics, modelOks, parenchymas, mcas, grays, deepgrays, whites, lefts, rights, Cerebellums] = ...
                       tabulateModalRois(metrics, modelOks, parenchymas, mcas, grays, deepgrays, whites, lefts, rights, Cerebellums)
            
            %% TABULATEMODALROIS displays a table of cell-array metrics
            %  as evaluated by row over ROIs for ASL-model-limits, no-CSF, MCA territory, ipsilateral hemisphere, 
            %  cortical tissue, deep basal ganglia, white matter.   Metrics is evaluated by columns over the 
            %  various imaging modalities, e.g., PET, ASL, DSC, LAIF
            %  See also:   assembleModalRois
            import mlfourd.*; 
            fprintf('RoiFactory.tabulateModalRois:\n');            
            
            %% prepare all inputs as RoiFactories
            metrics     = RoiFactory.toNIfTI(metrics);
            modelOks    = RoiFactory.toNIfTI(modelOks);
            parenchymas = RoiFactory.toNIfTI(parenchymas);
            mcas        = RoiFactory.toNIfTI(mcas);
            grays       = RoiFactory.toNIfTI(grays);
            deepgrays   = RoiFactory.toNIfTI(deepgrays);
            whites      = RoiFactory.toNIfTI(whites);
            lefts       = RoiFactory.toNIfTI(lefts);
            rights      = RoiFactory.toNIfTI(rights);            
            Cerebellums = RoiFactory.toNIfTI(Cerebellums);
            
            for m = 1:length(grays)
                grays{m} = grays{m} + whites{m};
                gtone    = grays{m} > 1;
                grays{m} = grays{m} .* (~gtone) + gtone;
                grays{m}.fileprefix = ['cortical' mlfsl.FlirtFacade.FLIRT_TOKEN RoiFactory.MODES{m}];
                grays{m}.save;
            end
            
            
            
            % permutations will be with fg, tissue, hemisphere RoiFactories
            % each modality gets separate, m-indexe RoiFactories
            nModes           = length(metrics);
            metricFactories  = cell(1,nModes);
            modelokFactories = cell(1,nModes);           
            mcaFactories     = cell(1,nModes);
            fgFactories      = cell(1,nModes);
            ipsiFactories    = cell(1,nModes);            
            contraFactories  = cell(1,nModes);
            grayFactories    = cell(1,nModes);
            deepFactories    = cell(1,nModes);            
            whiteFactories   = cell(1,nModes);
            bellumFactories  = cell(1,nModes);
            
            %% prepare rescaled metrics
            ho15MeanVoxels = nan;
            for m = 1:nModes 
                
                metricFactories{m} = RoiFactory(metrics{m}, parenchymas{m} .* mcas{m} .* rights{m} .* whites{m});
                switch (m)
                    case 1
                        ho15MeanVoxels    = metricFactories{1}.meanVoxels;
                        ho15MeanVoxels    = ho15MeanVoxels{1};
                    case {3,4}                   
                        metricFactories{m}.roiLabels = {'contraNormalWhite'};
                        metricFactories{m} = metricFactories{m}.rescaleByReference(metricFactories{m}.theRois{1}, ...
                                                                                   ho15MeanVoxels);
                        metrics{m}         = metricFactories{m}.theMetric;
                end
                metricFactories{m}.printStats;
            end
            fprintf('\n\n');
            
            
            
            %% initialize modelOks, mcas, fg
            for m = 1:nModes
                fg             = modelOks{m} .* parenchymas{m} .* mcas{m};
                fg.fileprefix  = 'fg';
                modelokFactories{m} = RoiFactory(metrics{m}, modelOks{m} .* parenchymas{m});
                modelokFactories{m}.roiLabels = repmat({'modelOk'}, size(modelokFactories{m}.roiLabels));
                modelokFactories{m}.printStats('modelok');
            end            
            fprintf('\n');
            for m = 1:nModes
                fg             = modelOks{m} .* parenchymas{m} .* mcas{m};
                fg.fileprefix  = 'fg';
                mcaFactories{m} = RoiFactory(metrics{m}, mcas{m} .* modelOks{m});
                mcaFactories{m}.roiLabels = repmat({'mca'}, size(mcaFactories{m}.roiLabels));
                mcaFactories{m}.printStats('mca');
            end
            fprintf('\n');
            for m = 1:nModes
                fg             = modelOks{m} .* parenchymas{m} .* mcas{m};
                fg.fileprefix  = 'fg';
                fgFactories{m} = RoiFactory(metrics{m}, fg);
                fgFactories{m}.roiLabels = repmat({'fg'}, size(fgFactories{m}.roiLabels));
                fgFactories{m}.printStats('fg');
            end
            fprintf('\n\n');         
            
            
            
            %% ipsi(modelOks), contra(modelOks)
            fprintf('modelOks:');
            for m = 1:nModes
                ipsiFactories{m} = RoiFactory(metrics{m}, lefts{m});
                ipsiFactories{m} = ipsiFactories{m}.restrictAllRois(modelokFactories{m});
                ipsiFactories{m}.printStats(lefts{m}.label); 
            end
            fprintf('\n');
            fprintf('modelOks:');
            for m = 1:nModes
                contraFactories{m} = RoiFactory(metrics{m}, rights{m});
                contraFactories{m} = contraFactories{m}.restrictAllRois(modelokFactories{m});
                contraFactories{m}.printStats(rights{m}.label); 
            end            
            fprintf('\n\n');
            
            %% ipsi(mcas), contra(mcas); reset ipsi/contra-factories
            fprintf('mcas:');
            for m = 1:nModes
                ipsiFactories{m} = RoiFactory(metrics{m}, lefts{m});
                ipsiFactories{m} = ipsiFactories{m}.restrictAllRois(mcaFactories{m});
                ipsiFactories{m}.printStats(lefts{m}.label); 
            end
            fprintf('\n');
            fprintf('mcas:');
            for m = 1:nModes
                contraFactories{m} = RoiFactory(metrics{m}, rights{m});
                contraFactories{m} = contraFactories{m}.restrictAllRois(mcaFactories{m});
                contraFactories{m}.printStats(rights{m}.label); 
            end            
            fprintf('\n\n');
                        
            %% ipsi(fg), contra(fg); reset ipsi/contra-factories
            fprintf('fg:');
            for m = 1:nModes
                ipsiFactories{m} = RoiFactory(metrics{m}, lefts{m});
                ipsiFactories{m} = ipsiFactories{m}.restrictAllRois(fgFactories{m});
                ipsiFactories{m}.printStats(lefts{m}.label); 
            end
            fprintf('\n');
            fprintf('fg:');
            for m = 1:nModes
                contraFactories{m} = RoiFactory(metrics{m}, rights{m});
                contraFactories{m} = contraFactories{m}.restrictAllRois(fgFactories{m});
                contraFactories{m}.printStats(rights{m}.label); 
            end            
            fprintf('\n\n');
            
            
            
            %% gray(fg), deep(fg), white(fg), bellum(fg); reset factories
            for m = 1:nModes 
                  grayFactories{m} = RoiFactory(metrics{m}, grays{m});               
                  grayFactories{m} = grayFactories{m}.restrictAllRois(fgFactories{m});
                  grayFactories{m}.printStats(grays{m}.label, 'fg'); 
            end            
            fprintf('\n');
            for m = 1:nModes 
                  deepFactories{m} = RoiFactory(metrics{m}, deepgrays{m});               
                  deepFactories{m} = deepFactories{m}.restrictAllRois(fgFactories{m});
                  deepFactories{m}.printStats(deepgrays{m}.label, 'fg'); 
            end            
            fprintf('\n');
            for m = 1:nModes 
                 whiteFactories{m} = RoiFactory(metrics{m}, whites{m});               
                 whiteFactories{m} = whiteFactories{m}.restrictAllRois(fgFactories{m});
                 whiteFactories{m}.printStats(whites{m}.label, 'fg'); 
            end            
            fprintf('\n');
            for m = 1:nModes 
                bellumFactories{m} = RoiFactory(metrics{m}, Cerebellums{m});               
                bellumFactories{m} = bellumFactories{m}.restrictAllRois(fgFactories{m});
                bellumFactories{m}.printStats(Cerebellums{m}.label, 'fg'); 
            end            
            fprintf('\n\n');
            
            %% gray(ipsi), deep(ipsi), white(ipsi), bellum(ipsi); reset factories
            for m = 1:nModes   
                  grayFactories{m} = RoiFactory(metrics{m}, grays{m});            
                  grayFactories{m} = grayFactories{m}.restrictAllRois(ipsiFactories{m});
                  grayFactories{m}.printStats(grays{m}.label, 'ipsi'); 
            end            
            fprintf('\n');
            for m = 1:nModes  
                  deepFactories{m} = RoiFactory(metrics{m}, deepgrays{m});              
                  deepFactories{m} = deepFactories{m}.restrictAllRois(ipsiFactories{m});
                  deepFactories{m}.printStats(deepgrays{m}.label, 'ipsi'); 
            end            
            fprintf('\n');
            for m = 1:nModes
                 whiteFactories{m} = RoiFactory(metrics{m}, whites{m});              
                 whiteFactories{m} = whiteFactories{m}.restrictAllRois(ipsiFactories{m});
                 whiteFactories{m}.printStats(whites{m}.label, 'ipsi'); 
            end            
            fprintf('\n');
            for m = 1:nModes    
                bellumFactories{m} = RoiFactory(metrics{m}, Cerebellums{m});          
                bellumFactories{m} = bellumFactories{m}.restrictAllRois(ipsiFactories{m});
                bellumFactories{m}.printStats(Cerebellums{m}.label, 'ipsi'); 
            end            
            fprintf('\n\n');            
           
            %% gray(contra), deep(contra), white(contra), bellum(contra); reset factories
            for m = 1:nModes    
                  grayFactories{m} = RoiFactory(metrics{m}, grays{m});           
                  grayFactories{m} = grayFactories{m}.restrictAllRois(contraFactories{m});
                  grayFactories{m}.printStats(grays{m}.label, 'contra'); 
            end            
            fprintf('\n');
            for m = 1:nModes    
                  deepFactories{m} = RoiFactory(metrics{m}, deepgrays{m});            
                  deepFactories{m} = deepFactories{m}.restrictAllRois(contraFactories{m});
                  deepFactories{m}.printStats(deepgrays{m}.label, 'contra'); 
            end            
            fprintf('\n');
            for m = 1:nModes    
                 whiteFactories{m} = RoiFactory(metrics{m}, whites{m});          
                 whiteFactories{m} = whiteFactories{m}.restrictAllRois(contraFactories{m});
                 whiteFactories{m}.printStats(whites{m}.label, 'contra'); 
            end            
            fprintf('\n');           
            for m = 1:nModes  
                bellumFactories{m} = RoiFactory(metrics{m}, Cerebellums{m});             
                bellumFactories{m} = bellumFactories{m}.restrictAllRois(contraFactories{m});
                bellumFactories{m}.printStats(Cerebellums{m}.label, 'contra'); 
            end            
            fprintf('\n\n');
            
        end % tabulateModalRois
        function fp  = toFileprefix(nii)
            
            %% TOFILEPREFIX converts fileprefixes or NIfTIs to well-formed fileprefixes
            import mlfourd.*;
            if (iscell(nii))
                fp = cell(1,length(nii));
                for f = 1:length(nii)
                    fp{f} = RoiFactory.toNIfTI(nii{f});
                end
            else
                if (isa(nii, 'mlfourd.ImageInterface'))
                    fp = nii.fileprefix;
                elseif (ischar(nii))
                    fp = fileprefix(nii);
                else
                    error('mlfourd:UnsupportedType', 'class(nii)->%s', class(nii));
                end
            end
        end        
        function nii = toNIfTI(fp)
            
            %% TONIFTI converts fileprefixes or NIfTIs to well-formed NIfTIs
            import mlfourd.*;
            if (iscell(fp))
                nii = cell(1,length(fp));
                for f = 1:length(fp)
                    nii{f} = RoiFactory.toNIfTI(fp{f});
                end
            else
                if (ischar(fp))
                    nii = NIfTI.load(fp);
                elseif (isa(fp, 'mlfourd.ImageInterface'))
                    nii = NIfTI(fp);
                elseif (isa(fp, 'mlfourd.RoiFactory'))
                    nii = NIfTI(fp.intersectionRois);
                else
                    error('mlfourd:UnsupportedType', 'class(fp)->%s', class(fp));
                end
            end
        end
    end % static methods
    
    
    
    methods
        function lbl  = get.metricLabel(this)
            lbl = this.theMetric.label;
        end
        function lbls = get.roiLabels(this)
            Nrois = numel(this.theRois);
            lbls  = cell(1,Nrois);
            for r = 1:Nrois
                lbls{r} = this.theRois{r}.label;
            end
        end
        function this = set.roiLabels(this, lbls)
            Nrois = numel(this.theRois);
            assert(Nrois == length(lbls));
            for r = 1:Nrois
                this.theRois{r}.label = lbls{r};
            end
        end
        function vecs = sampleVoxels(this, choice)
            
            %% SAMPLEVOXELS samples metric-voxels with some or all internal ROIs
            import mlfourd.*;            
            niib = NiiBrowser(this.theMetric);
            switch (nargin)
                case 1
                    vecs = cell(1,length(this.theRois));
                    for v = 1:length(vecs)
                        vecs{v} = niib.sampleVoxels(this.theRois{v});
                    end
                case 2                    
                    v = 1;
                    if (ischar(choice))
                        for r = 1:length(this.theRois)
                            if (lstrfind(this.theRois{r}.label, choice))
                                v = r; break;
                            end
                        end
                    else
                        assert(isnumeric(choice));
                        v = choice;
                    end
                    vecs = { niib.sampleVoxels(this.theRois{v})};
            end
        end % sampleVoxels
        function n    = nVoxels(this, choice)
            switch (nargin)
                case 1
                    sv = this.sampleVoxels;
                case 2
                    sv = this.sampleVoxels(choice);
            end
            if (~iscell(sv)); sv = {sv}; end
            n = cell(1,length(sv));
            for nidx = 1:numel(n)
                n{nidx} = numel(sv{nidx});
            end
        end
        function m    = meanVoxels(this, choice)
            switch (nargin)
                case 1
                    sv = this.sampleVoxels;
                case 2
                    sv = this.sampleVoxels(choice);
            end
            m = cell(size(sv));
            for midx = 1:numel(m)
                m{midx} = mean(sv{midx});
            end
        end
        function s    = stdVoxels(this, choice)
            sv = this.sampleVoxels(choice);
            if (iscell(sv)); sv = sv{1}; end
            s = std(sv);
        end
        function        printStats(this, choice, lbl)
            chstr = 1; 
            if (nargin > 1)
                if (isnumeric(choice))
                    chstr = ['roi#' num2str(choice)];
                else
                    chstr = char(choice);
                end
            end
            if (nargin > 2)
                chstr = [chstr '(x)' lbl];
            end
            fprintf('%s(x)%s: \t %s \t %s \t %s; \t', ...
                this.metricLabel, chstr, ...
                cell2str(this.nVoxels(   chstr)), ...
                cell2str(this.meanVoxels(chstr)), ...
                cell2str(this.stdVoxels( chstr)));
        end
    end
    
    
    
    methods (Access = 'protected')
        
        function this = RoiFactory(metric, rois)
            
            %% CTOR
            %  Usage: this = mlfourd.RoiFactory(metric [, rois])
            %         ^ factory                 ^         ^ fileprefixes or NIfTIs
            import mlfourd.*;
            if (nargin > 0)
                this.theMetric = RoiFactory.toNIfTI(metric);
            end
            if (nargin > 1)
                if (~iscell(rois)); rois = {rois}; end;
                this.theRois = RoiFactory.toNIfTI(rois);
            end
        end % ctor
           
        
        
        function this = load(this, object)
            
            %% LOAD appends object, converted to NIfTI, to this.theRois
            import mlfourd.*;            
            nNiis0 = length(this.theRois);
            if (~iscell(object)); object = {object}; end
            for o = 1:length(object)
                this.theRois{nNiis0 + o} = RoiFactory.toNIfTI(object{o});
            end
        end % load        
        function this = restrictAllRois(this, fg)
            
            import mlfourd.*;
            fg = RoiFactory.toNIfTI(fg);
            for n = 1:length(this.theRois)
                tmp = this.theRois{n};
                tmp = fg .* tmp;
                tmp.fileprefix = [fg.fileprefix '(x)' this.theRois{n}.fileprefix];
                this.theRois{n} = tmp;
            end
        end % restrictAllRois        
        function iroi = intersectionRois(this)
            iroi = this.theMetric.ones;
            for r = 1:length(this.theRois)
                iroi = iroi .* this.theRois{r};
            end
        end        
        function this = intersectNbyM(this, miis)
            
            %% INTERSECTNBYM intersects all this.theRois with the intersection of all miis,
            %  placing the product of intersections back in this.theRois
            import mlfourd.*;
            if (~iscell(miis)); miis = {miis}; end;
            for n = 1:length(this.theRois)
                for m = 1:length(miis)
                    miis{m} = RoiFactory.toNIfTI(miis{m});
                    tmp = this.theRois{n};
                    tmp = miis{m} .* tmp;
                    tmp.fileprefix = [miis{m}.fileprefix '(x)' this.theRois{n}.fileprefix];
                    this.theRois{n} = tmp;
                end
            end
        end  % intersectNbyM        
        function this = rescaleByReference(this, refRoi, refMean)
            
            %% RESCALEBYREFERENCE
            import mlfourd.*;
            metricb     = NiiBrowser(this.theMetric);
            metricMean  = mean(metricb.sampleVoxels(refRoi));
            this.theMetric = this.theMetric .* (refMean/metricMean);
            this.theMetric.fileprefix = [this.theMetric.fileprefix '_scaled2ref'];
        end
    end % methods
end % classdef RoiFactory


##### SOURCE END #####
--></body></html>